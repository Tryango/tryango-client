#include "common.hpp"
#include "angProofs.h"
#ifdef __APPLE__
#include <Python/Python.h>
#else
#include <Python.h>
#endif

#ifdef WINDOWS
    #include <direct.h>
    #define GetCurrentDir _getcwd
#else
    #include <unistd.h>
    #define GetCurrentDir getcwd
#endif


/**********************************************
 * Test of angSsl
 **********************************************/

ConfiVerifier verifier;

class VerifyTest : public ::testing::Test {
 protected:
  // Per-test-case set-up.
  // Called before the first test in this test case.
  // Can be omitted if not needed.
};

struct test_t
{
  std::string input;
  std::string result;
};

TEST_F(VerifyTest,sha256){
  test_t tests[9];
  tests[0].input=std::string("abca");
  tests[0].result=std::string("\x5c\x3f\x67\xb7\xfa\x84\xdf\xbe\x11\x18\x38\x7c\xad\x14\x79\x39\x29\x84\x5a\x5b\xc7\xc0\x08\x0c\x4d\x83\x09\xd3\x7b\xaa\x68\xd0",32);
    /* Test vectors from FIPS 180-2: appendix B.1.  */
//     /* Test vectors from FIPS 180-2: appendix B.2.  */
  tests[1].input=std::string("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
  tests[1].result=std::string("\x24\x8d\x6a\x61\xd2\x06\x38\xb8\xe5\xc0\x26\x93\x0c\x3e\x60\x39\xa3\x3c\xe4\x59\x64\xff\x21\x67\xf6\xec\xed\xd4\x19\xdb\x06\xc1",32);
    /* Test vectors from the NESSIE project.  */
  tests[2].input=std::string("");
  tests[2].result=std::string("\xe3\xb0\xc4\x42\x98\xfc\x1c\x14\x9a\xfb\xf4\xc8\x99\x6f\xb9\x24\x27\xae\x41\xe4\x64\x9b\x93\x4c\xa4\x95\x99\x1b\x78\x52\xb8\x55",32);
  tests[3].input=std::string("a");
  tests[3].result=std::string("\xca\x97\x81\x12\xca\x1b\xbd\xca\xfa\xc2\x31\xb3\x9a\x23\xdc\x4d\xa7\x86\xef\xf8\x14\x7c\x4e\x72\xb9\x80\x77\x85\xaf\xee\x48\xbb",32);
  tests[4].input=std::string("message digest");
  tests[4].result=std::string("\xf7\x84\x6f\x55\xcf\x23\xe1\x4e\xeb\xea\xb5\xb4\xe1\x55\x0c\xad\x5b\x50\x9e\x33\x48\xfb\xc4\xef\xa3\xa1\x41\x3d\x39\x3c\xb6\x50",32);
  tests[5].input=std::string("abcdefghijklmnopqrstuvwxyz");
  tests[5].result=std::string("\x71\xc4\x80\xdf\x93\xd6\xae\x2f\x1e\xfa\xd1\x44\x7c\x66\xc9\x52\x5e\x31\x62\x18\xcf\x51\xfc\x8d\x9e\xd8\x32\xf2\xda\xf1\x8b\x73",32);
  tests[6].input=std::string("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
  tests[6].result=std::string("\x24\x8d\x6a\x61\xd2\x06\x38\xb8\xe5\xc0\x26\x93\x0c\x3e\x60\x39\xa3\x3c\xe4\x59\x64\xff\x21\x67\xf6\xec\xed\xd4\x19\xdb\x06\xc1",32);
  tests[7].input=std::string("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
  tests[7].result=std::string("\xdb\x4b\xfc\xbd\x4d\xa0\xcd\x85\xa6\x0c\x3c\x37\xd3\xfb\xd8\x80\x5c\x77\xf1\x5f\xc6\xb1\xfd\xfe\x61\x4e\xe0\xa7\xc8\xfd\xb4\xc0",32);
  tests[8].input=std::string("12345678901234567890123456789012345678901234567890123456789012345678901234567890");
  tests[8].result=std::string("\xf3\x71\xbc\x4a\x31\x1f\x2b\x00\x9e\xef\x95\x2d\xd8\x3c\xa8\x0e\x2b\x60\x02\x6c\x8e\x93\x55\x92\xd0\xf9\xc3\x08\x45\x3c\x81\x3e",32);
  char sum[33];
  int cnt;

  for (cnt = 0; cnt < (int) (sizeof (tests) / sizeof (tests[0])); ++cnt){
    ConfiVerifier::hash(tests[cnt].input, sum);
    ASSERT_TRUE(memcmp (tests[cnt].result.c_str(), sum, 32) == 0);
  }

  /* Test vector from FIPS 180-2: appendix B.3.  */
  char buf[1000];
  memset (buf, 'a', sizeof (buf));
  SHA256_CTX sha256;
  SHA256_Init(&sha256);
  for (int i = 0; i < 1000; ++i)
      SHA256_Update(&sha256, buf, sizeof (buf));
  SHA256_Final((unsigned char*)sum, &sha256);
  static const char expected[] =
    "\xcd\xc7\x6e\x5c\x99\x14\xfb\x92\x81\xa1\xc7\xe2\x84\xd7\x3e\x67\xf1\x80\x9a\x48\xa4\x97\x20\x0e\x04\x6d\x39\xcc\xc7\x11\x2c\xd0";
  ASSERT_TRUE(memcmp (expected, sum, 32) == 0);

  SHA256_Init(&sha256);
  for (int i = 0; i < 100000; ++i)
      SHA256_Update(&sha256, buf, 10);
  SHA256_Final((unsigned char*)sum, &sha256);
  ASSERT_TRUE(memcmp (expected, sum, 32) == 0);
}

TEST_F(VerifyTest,Vpfcte){
  char hOld[] = "\xb5\x9b\x03\xa7\xbb\x46\x25\x41\x35\xb1\x33\x07\xdb\x29\x50\x6b\x97\x0f\xc9\xd2\xc8\x53\x9d\x8e\x1f\xcc\x6d\xba\xaf\x84\x6b\x8e";
  char hNew[] = "\x57\x85\x0a\x57\xf7\xcf\xc1\xcc\x06\x33\xdb\x07\xfc\x76\xce\xf0\x84\x9a\x46\xd2\xe7\x38\xfb\xe8\x87\x96\xa2\x05\x76\xd6\x4c\x38";
  char proof[] = "\xb5\x9b\x03\xa7\xbb\x46\x25\x41\x35\xb1\x33\x07\xdb\x29\x50\x6b\x97\x0f\xc9\xd2\xc8\x53\x9d\x8e\x1f\xcc\x6d\xba\xaf\x84\x6b\x8e\x23\x98\xe0\xad\x66\xef\xf0\xe4\x87\xf0\x92\x25\x02\x64\xda\xd0\x87\x03\xcf\xf2\x54\xeb\x45\x7f\x2f\x30\x57\x8f\x22\x83\xb5\x09";
  TreeNode oldRoot;
  oldRoot.hash=hOld;
  oldRoot.len=2;
  TreeNode newRoot;
  newRoot.hash=hNew;
  newRoot.len=3;

  ASSERT_TRUE(verifier.vpfcte(proof,oldRoot,newRoot));
  newRoot.len=2;
  ASSERT_FALSE(verifier.vpfcte(proof,oldRoot,newRoot));

  // hold,hnew=verify_proofs.vpfcte(proof,2,3)
}

TEST_F(VerifyTest,Vpfctp){
  std::string proof = std::string("", 0);
  TreeNode leaf;
  TreeNode root;

  leaf.hash = std::string("\x0a\x20\x2e\x5d\xf7\xce\x77\xcd\x4a\xfd\xe5\x6a\x74\x65\x60\x80\xc0\xaf\xd4\xf1\xe8\x47\x64\xeb\xd0\xa7\x81\x5a\x91\x00\xe3\xa4\x32\xfc\x12\x10\x31\x39\x37\x30\x30\x31\x30\x31\x54\x30\x30\x30\x30\x30\x30\x5a", 52);
  leaf.len = 1;
  root.hash = std::string("\x1b\xfb\x60\x6a\xa7\x2c\x59\x5a\x1a\x13\xb3\x84\xc5\xdf\x4f\x19\xbb\xbc\xb3\xb4\x08\x3e\x83\x58\x96\xe9\xf2\x95\xd1\xa6\x69\xe9", 32);
  root.len = 1;
  ASSERT_TRUE(verifier.vpfctp(proof, leaf, root));

  proof = std::string("\x1b\xfb\x60\x6a\xa7\x2c\x59\x5a\x1a\x13\xb3\x84\xc5\xdf\x4f\x19\xbb\xbc\xb3\xb4\x08\x3e\x83\x58\x96\xe9\xf2\x95\xd1\xa6\x69\xe9",32);
  leaf.hash = std::string("\x0a\x20\xa2\xb5\xaf\x4a\x75\xf2\xec\xf4\xee\x02\x95\x18\xd1\x1c\xbb\x3e\x3a\xf8\x79\x01\x35\x88\x45\x40\x5b\x7e\xbc\xab\x3e\x13\x5a\x0a\x12\x10\x32\x30\x31\x34\x30\x39\x32\x33\x54\x31\x36\x31\x39\x31\x39\x5a", 52);
  leaf.len = 2;
  root.hash = std::string("\x45\x06\x8b\x18\x6a\xf3\x01\x3f\xab\x06\x92\xcf\x57\xa5\xf9\x04\xac\x4d\xec\x6b\x9d\xaf\xde\xf9\x54\x36\x37\x70\x2d\xfe\x5f\xa8");
  root.len = 2;
  ASSERT_TRUE(verifier.vpfctp(proof, leaf, root));

  proof = std::string("\x3f\x31\x1b\x8e\xca\x78\x59\x5b\x88\x22\xef\xff\x33\x19\xb0\x1b\x99\x32\x9f\x16\x41\x36\x04\x48\x4f\xff\xde\x9d\x45\x6a\x73\x6c\xac\x49\x7b\xdc\xd9\x13\x85\x94\x6d\x9d\x74\xb7\xe6\x2e\x3e\xb7\x1c\x93\x57\x24\x0a\x0e\xe8\x93\xfa\x57\xd2\x61\xc1\x5f\x33\x03", 64);
  leaf.len = 6;
  leaf.hash = std::string("\x0a\x20\x16\x2c\x87\x3c\xa4\xd9\xec\xd2\x86\x24\x10\x21\xc1\x2f\x53\xed\x43\x7f\x4f\x11\xfe\x6f\x6c\x0d\x40\xf5\xcc\x09\x0c\x95\xf0\x40\x12\x10\x32\x30\x31\x34\x30\x39\x32\x33\x54\x31\x36\x31\x39\x32\x31\x5a", 52);
  root.hash = std::string("\xeb\xb5\x39\xd2\xf3\x82\x3a\x16\xf5\x13\x39\xe4\x17\xb2\xd6\x5d\x9f\x7a\x53\xbd\x12\x39\x32\xce\xdb\xb5\x08\x20\x8c\x90\x59\x6b", 32);
  root.len = 6;
  ASSERT_TRUE(verifier.vpfctp(proof, leaf, root));
}


TEST_F(VerifyTest,Vpfltpa){
  std::string lt_hash="\x7c\x43\x82\x22\x2f\xa6\x62\xa1\x99\x5e\x82\x9b\xde\x0c\x50\xde\x82\xa9\x02\x99\x40\x8a\x08\xe0\x3a\xac\xcd\x17\x9b\xd2\x4f\xd4";
  tryango::PFLTP proof;
  proof.ParseFromString(std::string("\x0a\x20\xb2\xdb\xcf\xd8\x97\xba\x09\xae\xf1\x2f\x91\x53\x68\x71\xfe\x2a\x42\x7d\x1f\xa5\x75\x31\xf8\x98\x43\xcd\x58\x62\x4c\x53\x85\xd2\x0a\x20\x2c\x30\xb6\xff\xcc\x10\xa8\x1c\xa2\x3e\x4a\x15\x14\x7d\xd3\xdd\xf0\x63\x3d\x36\x3f\x90\xf7\x1a\xd8\xa7\xa5\xf9\xa3\xcb\x2f\x95"));
  std::string key="\x9a\xad\x2d\xad\xc8\x14\x8f\x43\x8f\x73\x2f\x01\xac\x2c\x84\x6b\x20\xdd\x9e\x55\x7a\x1d\x1c\xee\x61\x29\x40\x11\xa2\x9d\x87\x07";
  ASSERT_TRUE(verifier.vpfltpa(lt_hash, proof, key, NULL));
  lt_hash="\x7c\x43\x82\x22\x2f\xa6\x62\xa1\x99\x5e\x82\x9b\xde\x0c\x50\xde\x82\xa9\x02\x99\x40\x8a\x08\xe0\x3a\xac\xcd\x17\x9b\xd2\x4f\xd4";
  proof.ParseFromString(std::string("\x0a\x20\xb2\xdb\xcf\xd8\x97\xba\x09\xae\xf1\x2f\x91\x53\x68\x71\xfe\x2a\x42\x7d\x1f\xa5\x75\x31\xf8\x98\x43\xcd\x58\x62\x4c\x53\x85\xd2\x0a\x20\x2c\x30\xb6\xff\xcc\x10\xa8\x1c\xa2\x3e\x4a\x15\x14\x7d\xd3\xdd\xf0\x63\x3d\x36\x3f\x90\xf7\x1a\xd8\xa7\xa5\xf9\xa3\xcb\x2f\x95"));
  key="\x9d\xc4\x15\x32\x5a\x95\xc6\xe2\x55\x8b\xf1\x41\xa8\x77\x2a\x17\x5d\xe4\x9b\x08\xf0\xa0\x27\xc8\x72\x0a\xd9\x42\xd6\xec\x63\xf7";
  ASSERT_TRUE(verifier.vpfltpa(lt_hash, proof, key, NULL));
  std::string entry_set=std::string("\x2a\x20\x3b\xc5\x10\x62\x97\x3c\x45\x8d\x5a\x6f\x2d\x8d\x64\xa0\x23\x24\x63\x54\xad\x7e\x06\x4b\x1e\x4e\x00\x9e\xc8\xa0\x69\x9a\x30\x43\x40\x02",36);
  lt_hash="\x7c\x43\x82\x22\x2f\xa6\x62\xa1\x99\x5e\x82\x9b\xde\x0c\x50\xde\x82\xa9\x02\x99\x40\x8a\x08\xe0\x3a\xac\xcd\x17\x9b\xd2\x4f\xd4";
  proof.ParseFromString(std::string("\x0a\x20\xea\xfb\x4e\x83\x25\x1a\x7c\x61\x04\xc8\x10\x17\x42\x13\xc9\x38\x59\x05\xb1\x33\x0b\xd8\x89\xe1\xbc\xa3\x60\xbc\x02\xfb\x57\xd8\x0a\x20\xcd\xa3\x32\xbe\x8a\xc3\x5a\x80\x38\x55\xf4\x95\x50\x5a\x43\x70\x91\xb5\xa6\xe1\xfc\x92\x33\x7a\x17\x1d\x61\x1d\x86\xa1\x43\x7e"));
  key=std::string("\x3b\xc5\x10\x62\x97\x3c\x45\x8d\x5a\x6f\x2d\x8d\x64\xa0\x23\x24\x63\x54\xad\x7e\x06\x4b\x1e\x4e\x00\x9e\xc8\xa0\x69\x9a\x30\x43", 32);
  ASSERT_TRUE(verifier.vpfltpa(lt_hash, proof, key, &entry_set));
  lt_hash=std::string("\x7c\x43\x82\x22\x2f\xa6\x62\xa1\x99\x5e\x82\x9b\xde\x0c\x50\xde\x82\xa9\x02\x99\x40\x8a\x08\xe0\x3a\xac\xcd\x17\x9b\xd2\x4f\xd4",32);
  proof.ParseFromString(std::string("\x0a\x20\xea\xfb\x4e\x83\x25\x1a\x7c\x61\x04\xc8\x10\x17\x42\x13\xc9\x38\x59\x05\xb1\x33\x0b\xd8\x89\xe1\xbc\xa3\x60\xbc\x02\xfb\x57\xd8\x0a\x20\xcd\xa3\x32\xbe\x8a\xc3\x5a\x80\x38\x55\xf4\x95\x50\x5a\x43\x70\x91\xb5\xa6\xe1\xfc\x92\x33\x7a\x17\x1d\x61\x1d\x86\xa1\x43\x7e\x12\x24\x2a\x20\x3b\xc5\x10\x62\x97\x3c\x45\x8d\x5a\x6f\x2d\x8d\x64\xa0\x23\x24\x63\x54\xad\x7e\x06\x4b\x1e\x4e\x00\x9e\xc8\xa0\x69\x9a\x30\x43\x40\x02",106));
  key=std::string("\x01\x49\x4b\x8b\xdb\xbe\x0f\x3e\x35\x7c\xd3\xdc\x37\x1c\x88\x7c\x14\x17\xc8\x17\x3b\xd3\x7b\xac\x61\x20\x78\x60\x82\x20\x65\x5b",32);
  ASSERT_TRUE(verifier.vpfltpa(lt_hash, proof, key, NULL));

}
